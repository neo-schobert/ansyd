"""
Simplified Vulnerability Report Generator

Generates security assessment reports by sending all data directly to the LLM.
"""

from dataclasses import asdict
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional


class VulnerabilityReportGenerator:
    """Simplified report generator - dumps all data to LLM"""
    
    def __init__(self, openrouter_client):
        self.client = openrouter_client
    
    def _make_serializable(self, obj):
        """Recursively convert any object to JSON-serializable format"""
        if isinstance(obj, (str, int, float, bool, type(None))):
            return obj
        elif isinstance(obj, (list, tuple, set)):
            return [self._make_serializable(item) for item in obj]
        elif isinstance(obj, dict):
            return {key: self._make_serializable(val) for key, val in obj.items()}
        elif hasattr(obj, '__dict__'):
            # Convert object to dict using its attributes
            return self._make_serializable(obj.__dict__)
        else:
            # Fallback: convert to string
            return str(obj)
    
    def generate_report(
        self,
        vuln_data: Dict[str, Any],
        call_graph_data,
        impact_analysis,
        exploit_db_desc: str,
        project_name: Optional[str] = None
    ) -> str:
        """
        Generate vulnerability report by sending all data to LLM.
        
        Args:
            vuln_data: Vulnerability data from cve_checker (Dict)
            call_graph_data: Call graph from ast_analyzer (CallGraphData or dict)
            impact_analysis: Impact analysis from cve_impact_analyzer (ImpactAnalysis or dict)
            exploit_db_desc: Exploit database descriptions (str)
            project_name: Optional project name
            
        Returns:
            Markdown-formatted report
        """
        print("Generating vulnerability report with AI...")
        
        # Validate inputs
        if not isinstance(vuln_data, dict):
            raise TypeError(f"vuln_data must be dict, got {type(vuln_data).__name__}")
        
        # Check if impact_analysis has the right attributes/keys
        if hasattr(impact_analysis, 'functions') and not hasattr(impact_analysis, 'vulnerable_functions'):
            raise TypeError(
                f"Wrong argument order! impact_analysis appears to be CallGraphData. "
                f"Expected order: vuln_data, call_graph_data, impact_analysis, exploit_db_desc"
            )
        
        # Build the prompt with all data
        prompt = self._build_prompt(
            vuln_data,
            call_graph_data,
            impact_analysis,
            exploit_db_desc,
            project_name
        )

        print(f"Prompt size (chars): {len(prompt)}")
        
        # Send to LLM
        response = self.client.query_with_retries(
            prompt=prompt,
            system_prompt=self._get_system_prompt(),
            max_retries=3
        )

        print("Report generation complete.")
        
        # Add metadata header
        report = self._add_header(response.content, project_name, vuln_data, impact_analysis)
        
        return report
    
    def _get_system_prompt(self) -> str:
        """System prompt defining the LLM's role"""
        return """You are a senior cybersecurity analyst specializing in C/C++ vulnerability assessment.

Your task is to analyze vulnerability data and generate a professional security assessment report.

Focus on:
- Distinguishing real vulnerabilities from false positives
- Assessing actual risk based on code usage
- Providing actionable mitigation recommendations
- Prioritizing vulnerabilities by exploitability and impact"""
    
    def _build_prompt(
        self,
        vuln_data: Dict[str, Any],
        call_graph_data,
        impact_analysis,
        exploit_db_desc: str,
        project_name: Optional[str]
    ) -> str:
        """Build complete prompt with all data"""
        
        project_name = project_name or "C++ Project"
        
        # Convert data to JSON strings for dumping
        vuln_json = self._serialize_vuln_data(vuln_data)
        print("Serializing complete vuln_data...")

        print(call_graph_data)
        call_graph_json = self._serialize_call_graph(call_graph_data)
        print("Serialization complete. Building prompt...")
        impact_json = self._serialize_impact_analysis(impact_analysis)
        
        print("Serialization complete. Building prompt...")

        prompt = f"""# Role Context
You are a Senior Application Security Engineer specializing in Software Composition Analysis (SCA) and Reachability Analysis. Your goal is to produce a high-fidelity security assessment for the project **{project_name}**.

# Input Data
I will provide you with three specific datasets. Please parse them carefully:

<data:cve_dependencies>
{vuln_json}
</data:cve_dependencies>

<data:call_graph>
{call_graph_json}
</data:call_graph>

<data:impact_context>
{impact_json}
</data:impact_context>

<data:exploit_db>
{exploit_db_desc}
</data:exploit_db>

# Analysis Logic (Step-by-Step)
Before generating the report, perform the following logical steps:
1.  **Map Vulnerabilities to Usage**: Cross-reference the CVE list with the Call Graph.
2.  **Determine Reachability**:
    * **Reachable**: The vulnerable function is explicitly invoked in the call graph. (Mark as CRITICAL/HIGH).
    * **Unreachable**: The dependency is present, but the vulnerable function is never called. (Downgrade priority).
3.  **Assess Exploitability**: Correlate with Exploit-DB data. If a public exploit exists AND the code is reachable, this is an immediate emergency.

# Output: Security Assessment Report
Please generate the report in Markdown format using the following structure:

## 1. Executive Summary
* Brief overview of the security posture.
* Total CVEs found vs. Total *Reachable* CVEs (highlighting noise reduction).

## 2. Risk Priority Matrix (Reachable Vulnerabilities Only)
Create a table with the following columns:
| CVE ID | Severity | Dependency | Usage Context (Call Graph) | Exploit Availability | Remediation Priority |
|--------|----------|------------|----------------------------|----------------------|----------------------|

## 3. Deep Dive: Critical & Reachable Issues
For the top 3-5 most dangerous issues, provide:
* **The Threat**: What the CVE allows (RCE, XSS, etc.) based on Exploit-DB.
* **The Evidence**: Specifically trace the path from the Call Graph (e.g., `MainApp -> Helper -> VulnerableLib.func()`).
* **The Fix**: Precise version upgrade or code mitigation.

## 4. Remediation Strategy
* **Immediate Patches**: A checklist of dependencies to upgrade immediately.
* **Defense-in-Depth**: Architectural changes suggested by the impact analysis.
* **False Positives**: A list of CVEs that can be deprioritized because they are effectively unreachable in the current code path.
"""
        
        return prompt
    
    def _serialize_vuln_data(self, vuln_data: Dict[str, Any]) -> str:
        """Convert vulnerability data to JSON string"""
        serialized = {}
        
        for lib_name, lib_data in vuln_data.items():
            # lib_data is a VulnerabilityResult object
            if hasattr(lib_data, '__dict__'):
                # It's a VulnerabilityResult object - extract its data
                cves = []
                for cve in lib_data.cves:
                    # Each CVE is a CVEInfo object
                    if hasattr(cve, '__dict__'):
                        cves.append({
                            'cve_id': getattr(cve, 'cve_id', 'Unknown'),
                            'severity': getattr(cve, 'severity', 'Unknown'),
                            'cvss_score': getattr(cve, 'cvss_score', None),
                            'description': getattr(cve, 'description', 'No description'),
                            'published_date': getattr(cve, 'published_date', None),
                            'references': getattr(cve, 'references', [])
                        })
                    else:
                        # Already a dict
                        cves.append(cve)
                
                serialized[lib_name] = {
                    'library_name': getattr(lib_data, 'library_name', lib_name),
                    'version': getattr(lib_data, 'version', 'unknown'),
                    'cve_count': len(cves),
                    'checked_at': getattr(lib_data, 'checked_at', None),
                    'cves': cves
                }
            else:
                # Already dict format - just make sure it's clean
                serialized[lib_name] = self._make_serializable(lib_data)
        
        return json.dumps(serialized, indent=2)

    def _serialize_call_graph(self, call_graph_data) -> str:
        """Convert call graph to JSON string"""
        # Handle both CallGraphData object and dict
        if isinstance(call_graph_data, dict):
            # Make sure everything is serializable
            serialized = self._make_serializable(call_graph_data)
        else:
            # It's a CallGraphData object
            serialized = {
                'total_functions': len(call_graph_data.functions),
                'total_files': len(call_graph_data.file_functions),
                'functions': {},
                'call_graph': call_graph_data.call_graph,
                'files': call_graph_data.file_functions
            }
            
            # Include function details
            for name, func_info in call_graph_data.functions.items():
                serialized['functions'][name] = {
                    'name': func_info.name,
                    'files': func_info.files,
                    'line': func_info.line,
                    'calls': [asdict(call) for call in func_info.calls]
                }
        
        return json.dumps(serialized, indent=2)
    
    def _serialize_impact_analysis(self, impact_analysis) -> str:
        """Convert impact analysis to JSON string"""
        # Handle both ImpactAnalysis object and dict
        if isinstance(impact_analysis, dict):
            # Make sure everything is serializable
            serialized = self._make_serializable(impact_analysis)
        else:
            # It's an ImpactAnalysis object
            serialized = {
                'total_vulnerable_functions': len(impact_analysis.vulnerable_functions),
                'directly_vulnerable': list(impact_analysis.directly_vulnerable),
                'indirectly_vulnerable': list(impact_analysis.indirectly_vulnerable),
                'vulnerable_libraries': list(impact_analysis.vulnerable_libs),
                'vulnerability_chains': impact_analysis.vulnerability_chains
            }
        
        return json.dumps(serialized, indent=2)
    
    def _add_header(
        self,
        report_body: str,
        project_name: Optional[str],
        vuln_data: Dict[str, Any],
        impact_analysis
    ) -> str:
        """Add metadata header to report"""
        
        project_name = project_name or "C++ Project"
        
        header = f"""---
# Vulnerability Assessment Report

**Project:** {project_name}
**Date:** {datetime.now().strftime('%B %d, %Y')}
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---

{report_body}

---

*Report generated using AI-powered analysis*
*Model: {self.client.default_model}*
*Timestamp: {datetime.now().isoformat()}*
"""
        return header


# ============================================================================
# Public API
# ============================================================================

def generate_report(
    exploit_db_desc: str,
    vuln_data: Dict[str, Any],
    call_graph_data,
    impact_analysis,
    openrouter_client,
    project_name: Optional[str] = None
) -> str:
    """
    Generate vulnerability assessment report.
    
    Args:
        vuln_data: Vulnerability data from cve_checker
        call_graph_data: Call graph from ast_analyzer
        impact_analysis: Impact analysis from cve_impact_analyzer
        exploit_db_desc: Exploit database descriptions
        openrouter_client: Configured OpenRouterClient
        project_name: Optional project name
        
    Returns:
        Markdown-formatted report string
    """
    generator = VulnerabilityReportGenerator(openrouter_client)
    # print(f"call graph data is :{generator._serialize_call_graph(call_graph_data)}")
    # print(f"vulnerability data is :{vuln_data}")
    # print(f"exploit data is :{exploit_db_desc}")
    return generator.generate_report(
        vuln_data,
        call_graph_data,
        impact_analysis,
        exploit_db_desc,
        project_name
    )


def save_report(report: str, output_path: str) -> None:
    """Save report to file"""
    output_path = Path(output_path)
    
    if not output_path.suffix:
        output_path = output_path.with_suffix('.md')
    
    output_path.write_text(report, encoding='utf-8')
    print(f"Report saved to: {output_path}")


# ============================================================================
# CLI Entry Point
# ============================================================================

def main():
    """Command-line interface"""
    import argparse
    import sys
    import os
    
    parser = argparse.ArgumentParser(
        description='Generate AI-powered vulnerability assessment report'
    )
    parser.add_argument('vulnerabilities', help='Path to vulnerabilities JSON')
    parser.add_argument('call_graph', help='Path to call graph JSON')
    parser.add_argument('impact_analysis', help='Path to impact analysis JSON')
    parser.add_argument('--output', '-o', required=True, help='Output report file')
    parser.add_argument('--project-name', help='Project name for report')
    parser.add_argument('--model', help='OpenRouter model to use')
    parser.add_argument('--api-key', 
                       default=os.getenv('OPENROUTER_API_KEY'),
                       help='OpenRouter API key')
    
    args = parser.parse_args()
    
    if not args.api_key:
        print("Error: No API key provided", file=sys.stderr)
        print("Set OPENROUTER_API_KEY environment variable or use --api-key")
        sys.exit(1)
    
    try:
        # Load data
        print("Loading analysis data...")
        
        with open(args.vulnerabilities, 'r') as f:
            vuln_data = json.load(f)
        
        with open(args.call_graph, 'r') as f:
            cg_json = json.load(f)
        
        with open(args.impact_analysis, 'r') as f:
            impact_json = json.load(f)
        
        # Reconstruct objects
        from ast_analyzer import CallGraphData, FunctionInfo, FunctionCall
        from cve_impact_analyzer import ImpactAnalysis
        from exploit_db import find_cve_exploit_db
        
        call_graph = CallGraphData()
        for name, func_data in cg_json['functions'].items():
            calls = [FunctionCall(**call) for call in func_data['calls']]
            call_graph.functions[name] = FunctionInfo(
                name=func_data['name'],
                file=func_data['file'],
                line=func_data['line'],
                calls=calls
            )
        call_graph.call_graph = cg_json['call_graph']
        call_graph.file_functions = cg_json['file_functions']
        call_graph.file_call_graphs = cg_json['file_call_graphs']
        
        impact = ImpactAnalysis()
        impact.vulnerable_functions = set(impact_json['vulnerable_functions'])
        impact.directly_vulnerable = set(impact_json['directly_vulnerable'])
        impact.indirectly_vulnerable = set(impact_json['indirectly_vulnerable'])
        impact.vulnerable_libs = set(impact_json['vulnerable_libraries'])
        impact.vulnerability_chains = impact_json['vulnerability_chains']
        
        # Get exploit DB descriptions
        print("Fetching exploit database information...")
        cve_list = []
        for lib_name, lib_data in vuln_data.items():
            if hasattr(lib_data, 'cves'):
                cve_list.extend([cve.cve_id for cve in lib_data.cves])
            else:
                cve_list.extend([cve['cve_id'] for cve in lib_data.get('cves', [])])
        
        exploit_db_desc = find_cve_exploit_db(cve_list)
        
        # Create OpenRouter client
        from openrouter_client import create_client
        client = create_client(args.api_key, args.model)
        
        # Generate report
        print("\nGenerating vulnerability assessment report...\n")
        
        report = generate_report(
            vuln_data,
            call_graph,
            impact,
            exploit_db_desc,
            client,
            args.project_name
        )
        
        # Save report
        save_report(report, args.output)
        
        print(f"\nReport complete!")
        print(f"   Model used: {client.default_model}")
        print(f"   API calls: {client.request_count}")
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()